#!/bin/sh
# shellcheck shell=dash

# [[ $string == <glob> ]] in posix:
# https://stackoverflow.com/a/30387785

# instead of cat $file, do something like this?
# read -d $'\x04' name < "$file" 

replace() { # $2 with $3 in string $1
  h=${1%%"$2"*} ; t=${1#*"$2"} ; echo "$h$3$t"
}

extract() { # shortest substring from string $1 between $2 and $3
  local s=${1%%"$3"*} ; s=${s##*"$2"} ; echo "$s"
}

template() { # render a string with current context
  local input expr old_expr key ; input=$1
  while [ "${input#*"{% "[!" "]*" %}"*}" != "$input" ] ; do
    #echo "$input"
    expr="$(extract "$input" "{% " " %}")"
    old_expr=$expr
      while [ "${expr#*"{"[!\{\}]*"}"*}" != "$expr" ]; do
        #echo "  $expr"
        key="$(extract "$expr" "{" "}")"
        val="$(eval "echo \$__$key")"
        [ -z "$val" ] && { echo "missing key: $key, aborting" ; exit 1 ; }
        expr="$(replace "$expr" "{$key}" "$val")"
      done
    input="$(replace "$input" "{% $old_expr %}" "$expr")"
  done
  echo "$input"
}

s="aorst {% {{colo}_color0} %} aiorst {% {{colo}_color15} %}"

# TODO problem: make varsets sourceable shell scripts
# nb: associative arrays are not a thing

# WAAAAAAAAAAAAAAAAAAAAAAAAAAAIT
# why use variable when i can have a function
# and make the varsets actual shell scripts
# e.g a shell script that gathers data, parses it, and then calls a function
# to expose vars? wow am i stooopid

#     conf
# colo="limestone"
# val colo $colo # => __colo="limestone"
# imp $colo # => __limestone_color0="black"      # that is, import variables from varset1 as __varset1_var1 (no prepoc, just use its actual name)

#     limestone
# val color0 black
# val color15 white

#     result
# __limestone_color0="black"

import() {
  [ "$1" != "config" ] && varset=$1
  #[ "$2" != "config" ] && varset=$2_${varset}
  varset=$2_${varset}
  val() { eval "${varset}_$1='$2'" ; }
  while read -r line ; do
    if [ "${line#import}" != "$line" ]; then
      #echo "  # $line $varset"
      eval "$line $varset"
    else
      #echo "  # $line $varset"
      eval "$line"
    fi
  done < "$1"
}

import config

template "$s"



#s="aorst {% {{colo}_color0} %} aiorst {% {{colo}_color15} %}"
#
#__colo="limestone"
#__limestone_color0="#000000"
#__limestone_color15="#ffffff"
#
#zzz=0.5
#
##while ! (case $s in (*"{% "[!" "]*" %}"*) return 1 ;; esac) ; do
#while [ "${s#*"{% "[!" "]*" %}"*}" != "$s" ] ; do
#  echo "s: $s"
#  sleep $zzz
#  expr="$(extract "$s" "{% " " %}")"
#  echo ">> $expr"
#  old_expr=$expr
#
#    #while ! (case $expr in (*"{"[!\{\}]*"}"*) return 1 ;; esac); do
#    while [ "${expr#*"{"[!\{\}]*"}"*}" != "$expr" ]; do
#      key="$(extract "$expr" "{" "}")"
#      sleep $zzz
#      echo "  >> $key"
#      expr="$(replace "$expr" "{$key}" "$(eval "echo \$__$key")")"
#      sleep $zzz
#      echo "  e: $expr"
#    done
#
#  sleep $zzz
#  s="$(replace "$s" "{% $old_expr %}" "$expr")"
#done
#
#echo
#echo "s: $s"




#import() {
#  local varset=$1 ; shift
#  while read -r line ; do
#    >&2 echo "$varset: '$line' '$*'"
#    if [ "${line#import}" != "$line" ]; then
#      eval "$(replace "$line" "\$" "\$__")"
#    else
#      eval "$({
#        echo -n "__"
#        for prefix in "$@" ; do echo -n "${prefix}_" ; done
#        echo "$line"
#      })"
#    fi
#  done < "$varset"
#}
#
## "import limestone variables as ${colo}_variable"
#import config
