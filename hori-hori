#!/bin/bash

# TODO fzf

REPO="$HOME/.garden/etc"
HORI="$HOME/.config/hori"
PACK="" # package currently being processed

# {{{ -- awk land ---
read -r -d '' AWK <<'EOF'
BEGIN {
  FS=": "
} {
  # get indent in twos
  match($0, /^ */)
  indent = RLENGTH / 2

  # strip indent from the key
  key=substr($1, RLENGTH + 1)
  com=substr(key, 1, 1)

  # skip comments
  if (com != "#" && length(key) > 0) {
    val = ""
    # get everything after the first delimiter match
    for (i = 2; i <= NF; i++) {
      val = (val)($i)": "
    }
    # remove trailing delimiter
    val = substr(val, 1, length(val) - 2)

    # https://stackoverflow.com/a/21189044
    vname[indent] = key
    for (i in vname) {
      if (i > indent) { delete vname[i] }
    }
    if (length(val) > 0) {
      path = ""
      for (i = 0; i < indent; i++) {
        path = (path)(vname[i])"_"
      }
      if (substr(val, 1, 8) == "require ") {
        printf("%s '%s'\n", (val), (prefix)(path)(key)"_")
      } else {
        printf("__%s=%s\n", (prefix)(path)(key), val);
      }
    }
  }
}
EOF
# }}}

require() { # transpile config into bash variables
  local prefix="$2"
  local output="$(awk -v prefix="$prefix" "$AWK" "$REPO/hori-hori/$1")"
  while read -r line; do
    if [[ $line == "require "* ]]; then
      eval "$line"
    else
      echo "$line"
    fi
  done <<< "$output"
}

eval "$(require conf)" # load config

# -- templating engine --

template() { # render a string with config as context
  local input="$1"
  local expr_re='\{%[[:space:]]([^ ]+)[[:space:]]%\}'
  local leaf_re='\{([^\{\}]+)\}'
  while [[ $input =~ $expr_re ]]; do
    expr="${BASH_REMATCH[0]}"
    body="${BASH_REMATCH[1]}"
    while [[ $body =~ $leaf_re ]]; do
      key="__${BASH_REMATCH[1]}"
      body="${body/${BASH_REMATCH[0]}/${!key}}"
    done
    input="${input/$expr/$body}"
  done
  echo "$input"
}

# -- utils --

once() { # run function 2 in package 1 once if defined
  PACK="$1"
  . "$REPO/$PACK/hori.sh"
  if declare -F "$2" > /dev/null; then
    "$2" ; unset "$2"
  fi
}

readme() { # generate a readme based on currently used .files
  local txt="### .files currently in use"$'\n'"\`\`\`"$'\n'
  for p in $HORI/* ; do txt+="${p/$HORI\//}"$'\n' ; done
  txt+="\`\`\`"$'\n'"See [hori-hori](https://github.com/tsbohc/hori-hori) for more info."$'\n\n'
  txt+="> This readme is generated automatically and is always up to date."
  echo "$txt" > "$REPO/readme.md"
}

# -- package hooks --

render() { # render a file and return its stored path
  local source="$REPO/$PACK/$1"
  local target="$HORI/$PACK/$1"
  mkdir -p "$(dirname "$target")"
  template "$(<"$source")" > "$target"
  echo "$target"
}

link() { # create a symlink
  [[ "$1" == *"$HORI"* ]] && local source="$1" || local source="$REPO/$PACK/$1"
  local target="${2/\~/$HOME}"
  ln -sfn "$source" "$target"
}

unlink() { # remove a symlink
  local target="${1/\~/$HOME}"
  [[ -L "$target" ]] && rm "$target"
}

:grow() { # install package
  if [[ -d "$REPO/$1" ]]; then
    once "$1" grow
    mkdir -p "$HORI/$1"
  fi
}

:weed() { # uninstall package
  if [[ -d "$HORI/$1" ]]; then
    once "$1" weed # TODO check this
    rm -r "$HORI/$1"
  fi
}

subcmd="$1" ; shift
case "$subcmd" in
  s|-s|setup)  for p in "$@"; do :grow "$p"; done ; readme ;;
  r|-r|remove) for p in "$@"; do :weed "$p"; done ; readme ;;
  l|-l|list)   for p in $HORI/*; do echo "${p/$HORI\//}"; done ;;
  *) echo "hori-hori - tiny dotifles management and templating framework"$'\n' \
          "  <setup> or <remove> leaves"$'\n' \
          "  <list> installed leaves" ;;
esac
