#!/bin/bash

# hori-hori - versatile japanese gardening knife
# zsh completion how-to: compdef '_path_files -/ -W /home/sean/.garden/etc/' hori-hori

# TODO
# simplify hook calling, so that hori-hori -h grow [packages...] is valid instead of hori-hori s [p..]?

REPO="$HOME/.garden/etc"
HORI="$HOME/.config/hori"
PACK="" # package currently being processed

# -- nyoml to bash --

import() { # transpile toml-like config into into bash variables
  local prefix="$2"
  local section_re='^\[(.*)\]'
  local kvpair_re='(.*)[[:space:]]=[[:space:]](.*)'
  local import_re='\$\((import[[:space:]].*)\)'
  while read -r line; do
    if [[ $line =~ $section_re ]]; then
      local section="${BASH_REMATCH[1]/\./\_}_"
    elif [[ $line =~ $kvpair_re ]]; then
      [[ "$prefix" == "$section" ]] && \
        echo "__${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}" || \
        echo "__${prefix}${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
    elif [[ $line =~ $import_re ]]; then
      eval "${BASH_REMATCH[1]} ${section}"
    fi
  done < "$REPO/hori-hori/$1"
} ; eval "$(import conf)"

# -- templating engine --

template() { # render a string with config as context
  local input="$1"
  local expr_re='\{%[[:space:]]([^ ]+)[[:space:]]%\}'
  local leaf_re='\{([^\{\}]+)\}'
  while [[ $input =~ $expr_re ]]; do
    expr="${BASH_REMATCH[0]}"
    body="${BASH_REMATCH[1]}"
    while [[ $body =~ $leaf_re ]]; do
      key="__${BASH_REMATCH[1]}"
      body="${body/${BASH_REMATCH[0]}/${!key}}"
    done
    input="${input/$expr/$body}"
  done
  echo "$input"
}

# -- utils --

if command -v dunstify &> /dev/null; then
  notify() { # set up notifications if we can
    dunstify "hori" "$*"
  } ; else notify() { : ; } ; fi

once() { # run function 2 in package 1 once if defined
  PACK="$1"
  source "$REPO/$PACK/hori.sh"
  if declare -F "$2" > /dev/null; then
    "$2" ; unset "$2"
  fi
}

all() { # run $1 $p $2 for every installed package
  [[ "$1" == "once" ]] && notify "run '$2' for all installed"
  for p in "$HORI"/*; do
    "$1" "${p/$HORI\//}" "$2"
  done
}

readme() { # generate a readme based on currently used .files
  local txt="### .files currently in use"$'\n'"\`\`\`"$'\n'
  for p in "$HORI"/* ; do txt+="${p/$HORI\//}"$'\n' ; done
  txt+="\`\`\`"$'\n'"See [hori-hori](https://github.com/tsbohc/hori-hori) for more info."$'\n\n'
  txt+="> This readme is generated automatically and is always up to date."
  echo "$txt" > "$REPO/readme.md"
}

# -- package hooks --

render() { # render a file and return its stored path
  local source="$REPO/$PACK/$1"
  local target="$HORI/$PACK/$1"
  mkdir -p "$(dirname "$target")"
  template "$(<"$source")" > "$target"
  echo "$target"
}

link() { # create a symlink
  if [[ "$1" == *"$HORI"* ]] ; then local source="$1" ; else local source="$REPO/$PACK/$1" ; fi
  local target="${2/\~/$HOME}"
  mkdir -p "$(dirname "$target")" # TODO replace with string manipulation
  ln -sfn "$source" "$target"
}

unlink() { # remove a symlink
  local target="${1/\~/$HOME}"
  [[ -L "$target" ]] && rm "$target"
}

launch() { # kill existing process and run command
  pkill -x "$1" ; sleep 0.2 ; "$@"
}

:grow() { # install package
  if [[ -d "$REPO/$1" ]]; then
    once "$1" grow
    mkdir -p "$HORI/$1"
    notify "install $1"
  fi
}

:weed() { # uninstall package
  if [[ -d "$HORI/$1" ]]; then
    once "$1" weed
    rm -r "${HORI:?}/$1"
    notify "remove $1"
  fi
}

subcmd="$1" ; shift
case "$subcmd" in
  s|-s|setup)  for p in "$@"; do :grow "$p"; done ; readme ;;
  r|-r|remove) for p in "$@"; do :weed "$p"; done ; readme ;;
  l|-l|list)   all echo ;;
  h|-h|hook)   all once "$1" ;;
  *) echo "hori-hori - tiny dotfiles management and templating framework"$'\n' \
          "  <setup> or <remove> packages"$'\n' \
          "  <hook> run hook in all installed packages"$'\n' \
          "  <list> installed packages" ;;
esac
