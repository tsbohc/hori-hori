#!/bin/bash

# hori-hori - versatile japanese gardening knife, by tsbohc
# TODO verbose -v flag?

# zsh completion how-to: compdef '_path_files -/ -W /home/sean/.garden/etc/' hori-hori
# shellcheck disable=SC1090,SC2015 # non-constant paths and ternary-like ifs are in check

REPO="$HOME/.garden/etc"  # package repository
HORI="$HOME/.config/hori" # cache directory

# -- nyoml --

import() { # transpile toml-like config into into bash variables
  local prefix=$2
  local section_re='^\[(.*)\]'
  local kvpair_re='(.*)[[:space:]]=[[:space:]](.*)'
  local import_re='\$\((import[[:space:]].*)\)'
  while read -r line; do
    if [[ $line =~ $section_re ]]; then
      local section=${BASH_REMATCH[1]/\./\_}_
    elif [[ $line =~ $kvpair_re ]]; then
      if [[ $prefix == "$section" ]]; then
        echo "__${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}" ; else
        echo "__${prefix}${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}" ; fi
    elif [[ $line =~ $import_re ]]; then
      eval "${BASH_REMATCH[1]} ${section}"
    fi
  done < "$REPO/hori-hori/$1"
} ; eval "$(import conf)"

# -- templating engine --

template() { # render a string with config as context
  local input=$1
  local expr_re='\{%[[:space:]]([^ ]+)[[:space:]]%\}'
  local leaf_re='\{([^\{\}]+)\}'
  while [[ $input =~ $expr_re ]]; do
    expr=${BASH_REMATCH[0]}
    body=${BASH_REMATCH[1]}
    while [[ $body =~ $leaf_re ]]; do
      key=__${BASH_REMATCH[1]}
      body=${body/${BASH_REMATCH[0]}/${!key}}
    done
    input=${input/$expr/$body}
  done
  echo "$input"
}

# -- utils --

command -v dunstify &> /dev/null && \
  notify() { dunstify hori "$*" ; } || notify() { : ; }

command -v hori-readme &> /dev/null && \
  readme() { hori-readme ; } || readme() { : ; }

# -- package hooks --

render() { # render a file and return its stored path
  local source=$REPO/$PACK/$1
  local target=$HORI/$PACK/$1
  mkdir -p "$(dirname "$target")"
  template "$(<"$source")" > "$target"
  echo "$target"
}

link() { # create a symlink
  [[ $1 == *"$HORI"* ]] && local source=$1 || local source=$REPO/$PACK/$1
  local target=${2/\~/$HOME}
  mkdir -p "$(dirname "$target")" # TODO replace with string manipulation
  ln -sfn "$source" "$target"
}

unlink() { # remove a symlink
  local target=${1/\~/$HOME}
  [[ -L $target ]] && rm "$target"
}

launch() { # kill existing process and run command
  pkill -x "$1" ; sleep 0.2 ; "$@"
}

# -- triggering hooks --

hook() { # run hook 1 in package 2 once if defined
  PACK=$2
  [[ $1 == "setup" ]] && mkdir -p "$HORI/$PACK"
  (
  . "$REPO/$PACK/hori.sh"
  if declare -F "$1" > /dev/null; then
    notify "$1 $PACK" ; $1
  fi
  )
  [[ $1 == "remove" && -d "${HORI:?}/$PACK" ]] && rm -r "${HORI:?}/$PACK"
}

run() { # run $1 for every package of type $2 or in $@
  local cmd=$1 ; shift
  case $* in
    -i|--installed) packages=("$HORI/"*) ;;
    -a|--available) packages=("$REPO/"*) ;;
    *) packages=("$@") ;;
  esac
  for p in "${packages[@]}"; do
    $cmd "${p##*/}"
  done
}

# -- main --

subcmd=$1 ; shift
case $subcmd in
  -s|setup)  run "hook setup" "$@" ; readme ;;
  -r|remove) run "hook remove" "$@" ; readme ;;
  -k|hook)   _hook="hook $1" ; shift ; run "$_hook" "$@" ;;
  -e|exec)   run "$@" ;;
  *) echo "tiny dotfiles management and templating framework

USAGE
  \$ hori-hori <operation> <arguments>

  install or remove packages
    {-s, setup}    <package(s)>
    {-r, remove}   <package(s)>

  run hook in packages or command with package name as argument
    {-e, exec}     <command> (<package(s)> | -i | -a)
    {-k, hook}     <hook> (<package(s)> | -i | -a)

OPTIONS
  -h, --help       display this message
  -i, --installed  replaced with installed packages
  -a, --available  replaced with available packages" ;;
esac
