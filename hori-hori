#!/bin/bash

# hori-hori - versatile japanese gardening knife, by tsbohc
# zsh completion how-to: compdef '_path_files -/ -W /home/sean/.garden/etc/' hori-hori

REPO="$HOME/.garden/etc"  # package repository
HORI="$HOME/.config/hori" # cache directory

# --- nyoml to bash ---

import() { # transpile toml-like config into into bash variables
  local prefix=$2
  local section_re='^\[(.*)\]'
  local kvpair_re='(.*)[[:space:]]=[[:space:]](.*)'
  local import_re='\$\((import[[:space:]].*)\)'
  while read -r line; do
    if [[ $line =~ $section_re ]]; then
      local section=${BASH_REMATCH[1]/\./\_}_
    elif [[ $line =~ $kvpair_re ]]; then
      if [[ $prefix == "$section" ]]; then
        echo "__${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}" ; else
        echo "__${prefix}${section}${BASH_REMATCH[1]}=${BASH_REMATCH[2]}" ; fi
    elif [[ $line =~ $import_re ]]; then
      eval "${BASH_REMATCH[1]} ${section}"
    fi
  done < "$REPO/hori-hori/$1"
} ; eval "$(import conf)"

# -- templating engine --

template() { # render a string with config as context
  local input=$1
  local expr_re='\{%[[:space:]]([^ ]+)[[:space:]]%\}'
  local leaf_re='\{([^\{\}]+)\}'
  while [[ $input =~ $expr_re ]]; do
    expr=${BASH_REMATCH[0]}
    body=${BASH_REMATCH[1]}
    while [[ $body =~ $leaf_re ]]; do
      key=__${BASH_REMATCH[1]}
      body=${body/${BASH_REMATCH[0]}/${!key}}
    done
    input=${input/$expr/$body}
  done
  echo "$input"
}

# -- utils --

if command -v dunstify &> /dev/null; then
  notify() { # set up notifications if we can
    dunstify hori "$*"
  } ; else notify() { : ; } ; fi

hook() { # run hook 1 in package 2 once if defined
  PACK=$2
  # shellcheck disable=SC1090 #
  . "$REPO/$PACK/hori.sh"
  if declare -F "$1" > /dev/null; then
    notify "$1 $2"
    $1 ; unset "$1"
  fi
}

run() { # run $2 for every package of type $1 found in $@, with package name as the argument
  if [[ $1 == installed ]]; then
    local where=$HORI
  elif [[ $1 == available ]]; then
    local where=$REPO
  fi ; shift
  local cmd=$1 ; shift
  if [[ $* == "--all" ]]; then
    for k in "$where"/*; do
      $cmd "${k/$where\//}"
    done
  else
    for k in "$@"; do
      [[ -d "$where/$k" ]] && $cmd "${k/$where\//}"
    done
  fi
}

readme() { # generate a readme based on currently used .files
  local txt="### .files currently in use"$'\n'"\`\`\`"$'\n'
  for p in "$HORI"/* ; do txt+="${p/$HORI\//}"$'\n' ; done
  txt+="\`\`\`"$'\n'"See [hori-hori](https://github.com/tsbohc/hori-hori) for more info."$'\n\n'
  txt+="> This readme is generated automatically and is always up to date."
  echo "$txt" > "$REPO/readme.md"
}

# -- package hooks --

render() { # render a file and return its stored path
  local source=$REPO/$PACK/$1
  local target=$HORI/$PACK/$1
  mkdir -p "$(dirname "$target")"
  template "$(<"$source")" > "$target"
  echo "$target"
}

link() { # create a symlink
  if [[ $1 == *"$HORI"* ]] ; then local source=$1 ; else local source=$REPO/$PACK/$1 ; fi
  local target=${2/\~/$HOME}
  mkdir -p "$(dirname "$target")" # TODO replace with string manipulation
  ln -sfn "$source" "$target"
}

unlink() { # remove a symlink
  local target=${1/\~/$HOME}
  [[ -L $target ]] && rm "$target"
}

launch() { # kill existing process and run command
  pkill -x "$1" ; sleep 0.2 ; "$@"
}

# main

setup-wrapper()  { mkdir -p "$HORI/$1" ; hook setup "$1" ; }
remove-wrapper() { hook remove "$1" ; rm -r "${HORI:?}/$1" ; }

subcmd=$1 ; shift
case $subcmd in
  s|-s|setup)  run available setup-wrapper  "$@" ; readme ;;
  r|-r|remove) run installed remove-wrapper "$@" ; readme ;;
  installed)   _hook="$1" ; shift ; run installed "hook $_hook" "$@" ;;
  available)   _hook="$1" ; shift ; run available "hook $_hook" "$@" ;;
  l|-l|list)   run installed echo --all ;;
  *) echo "hori-hori - tiny dotfiles management and templating framework"$'\n' \
          "  <setup> or <remove> packages"$'\n' \
          "  <list> installed packages" ;;
esac
